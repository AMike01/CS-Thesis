\subsection{\textit{Backend}}
\label{sez:backend}

La struttura della \textit{repository} \gls{backend} è la seguente:

\begin{itemize}
    \item \textbf{\textit{src}}: Contiene le seguenti cartelle organizzate per funzionalità:
    \begin{itemize}
        \item \textbf{\textit{auth}}: Contiene i \textit{middleware} per l'autenticazione delle \gls{api};
        \item \textbf{\textit{aws-bedrock}}: Contiene la logica della generazione dei progetti;
        \item \textbf{\textit{draft-presets}}: Contiene la logica per il salvataggio, recupero ed eliminazione delle bozze;
        \item \textbf{\textit{pdf}}: Contiene la logica per la generazione e salvataggio su \textit{AWS S3} dei progetti;
        \item \textbf{\textit{project}}: Contiene la logica per il salvataggio, recupero ed eliminazione dei progetti;
        \item \textbf{\textit{prompt}}: Contiene la logica per il salvataggio, creazione ed eliminazione dei \gls{prompt};
        \item \textbf{\textit{preset}}: Contiene la logica dei \textit{preset};
        \item \textbf{\textit{utils}}: Contiene tutti i \textit{mock} utili per il \textit{testing} o funzioni di supporto globale.
    \end{itemize}
    \item \textbf{\textit{package.json}}: Contiene le dipendenze del progetto;
    \item \textbf{\textit{DockerFile}}: Contiene il file \textit{Docker} per la creazione del \gls{container} per \textit{MongoDB};
\end{itemize}

\noindent Per ogni cartella all'interno di \textit{src} (ad esclusione delle cartelle \textbf{\textit{auth}} e \textbf{\textit{utils}}), si ha una struttura comune che include:
\begin{itemize}
    \item una cartella \textit{dto} contenente i \gls{dtog} relativa alla funzionalità;
    \item una cartella \textit{schemas} contenente gli schema \gls{odmg} relativo all'entità gestita;
    \item un \textit{controller} per la gestione delle richieste \gls{http};
    \item un \textit{module} per l'iniezione delle dipendenze;
    \item un \textit{service} per la logica di \textit{business}.;
    \item i \textit{test} dei \textit{controller} e dei \textit{service}.
\end{itemize}

\pagebreak

\subsubsection{Autenticazione tramite \gls{jwt} e \textit{Middleware}}

Il \gls{frontend} dell'applicazione invia un \gls{jwtg} insieme ad ogni richiesta al \gls{backend}.\\
Questo \textit{token}, generato al momento dell'autenticazione dell'utente tramite \textit{AWS Cognito}, viene inserito nell'intestazione della richiesta (\textit{header}) sotto la chiave \texttt{Authorization}.\\
Il \gls{backend} utilizza un \textit{middleware} di autenticazione dedicato per verificare la validità del \textit{token}.\\ 

\noindent Il \textit{middleware} svolge le seguenti operazioni:
\begin{itemize}
    \item Estrae il \textit{token} \gls{jwt} dall'intestazione della richiesta;
    \item Verifica che il \textit{token} sia valido e non scaduto, utilizzando la chiave pubblica di \textit{AWS Cognito};
    \item Decodifica il \textit{token} per estrarre le informazioni sull'utente, come l'\textit{ID} e il ruolo, e le passa al contesto della richiesta per l'utilizzo nelle \gls{api};
    \item Rifiuta richieste non autorizzate, restituendo una risposta con codice di stato \texttt{401 Unauthorized}.
\end{itemize}

\subsubsection{\textit{Endpoints} delle \gls{api}}

Il sistema implementa diversi \textit{endpoints} per gestire le operazioni richieste dal \gls{frontend}.\\
Gli \textit{endpoints} relativi alle risorse \texttt{/projects}, \texttt{/presets} e \texttt{/draft-presets} si concentrano su operazioni standard di tipo \textit{CRUD} (\textit{Create}, \textit{Read}, \textit{Update}, \textit{Delete}).\\
Questi \textit{endpoints} consentono di creare, leggere, aggiornare o eliminare progetti, preset e bozze dal database, mantenendo una gestione centralizzata dei dati. Tuttavia, per la loro natura semplice e ripetitiva, non presentano aspetti tecnici particolarmente complessi o innovativi.\\

\noindent Di seguito vengono approfonditi gli \textit{endpoints} che implementano funzionalità più avanzate, offrendo interazioni significative tra il \gls{frontend}, il \gls{backend} e i servizi esterni.

\subsection*{\texttt{/aws-bedrock}}
L’\textit{endpoint} \texttt{/aws-bedrock} è progettato per gestire la generazione automatica dei progetti sfruttando le capacità di \textit{AWS Bedrock}.\\
La sua funzione principale è quella di orchestrare la comunicazione tra il sistema e un modello di linguaggio (\gls{llm}) avanzato, consentendo la creazione di progetti dettagliati.\\

\noindent Per garantire consistenza e affidabilità nel risultato, la configurazione di questo \textit{endpoint} utilizza \textit{LangChain}, un framework che supporta la definizione di output strutturati direttamente dall’\gls{llm}.\\
L’output strutturato è un formato predefinito, progettato per essere validato, assicurando che i dati siano conformi alle aspettative del sistema prima di essere restituiti al \gls{frontend}.\\
Grazie a \textit{LangChain}, è possibile gestire in modo efficace le interazioni con il \gls{llm}, costruendo flussi dati modulari e scalabili che riducono gli errori di interpretazione e aumentano l’affidabilità complessiva.\\

\noindent All'interno della {\hyperref[lst:funzione-generazione-progetto]{\textit{Listing} 3.3}} è possibile osservare la dichiarazione della \gls{llm} e la funzione di generazione dei progetti implementata nel \textit{service}, che si occupa di invocare il modello di linguaggio e restituire il risultato al \gls{frontend}.

\begin{lstlisting}[caption={Dichiarazione \gls{llm} e sua invocazione}, label={lst:funzione-generazione-progetto}]
private readonly llm: ChatBedrockConverse;
  constructor() {  
    // declare the LLM
    this.llm = new ChatBedrockConverse({
      model: "anthropic.claude-3-5-sonnet-20241022-v1:5",
      temperature: 0.3,
      topP: 0.9,
      maxTokens: 4096,
      region: "eu-central-1",
      // AWS credentials
      credentials: fromIni({ profile: "dev" }), 
    });
  }
  async generateProject(
    prompt: string,
    promptId: string,
    projectId: string
  ): Promise<CreateProjectDTO> {

    try {
      // Define the output schema
      const structuredLlm = this.llm.withStructuredOutput(ProjectSchema); 
      // Invoke the LLM
      const response = await structuredLlm.invoke(prompt); 
      const result : CreateProjectDTO = response;

      // Assign the promptId
      result.promptId = promptId; 
      // Assign the projectId
      result.projectId = projectId; 

      return result;
    } catch (error) {
      throw new Error(
        `Failed to generate project with AWS Bedrock: ${error.message}`
      );
    }
  }
\end{lstlisting}
\pagebreak
\noindent All'interno della {\hyperref[lst:funzione-generazione-progetto]{\textit{Listing} 3.4}} è possibile osservare una sezione dello schema creato tramite la libreria \textit{Zod}, da notare che ogni campo dello schema ha un tipo ed una descrizione associata. 

\begin{lstlisting}[caption={Schema \textit{Zod} dell'output dell'\gls{llm}}, label={lst:schema-zod}]
const IntroductionSchema = z.object({
  scopeOfDocument: z.string().describe("Scope of the document"),
  projectBackground: z.string().describe("Background of the project"),
  objectives: z.array(z.string()).describe("Objectives of the project"),
});

const ProjectScopeSchema = z.object({
  featuresAndFunctionalities: z
    .array(z.string())
    .describe("Features and functionalities of the project"),
  deliverables: z
    .array(z.string())
    .describe("Deliverables expected from the project"),
});

const DesignSchema = z.object({
  uxUiDesign: z.string().describe("Description about the UX/UI design choices"),
  keyDesignElements: z
    .array(z.string())
    .describe("Key design elements of the project"),
});
......
const ProjectSchema = z.object({
  projectName: z.string().describe("Name of the project"),
  projectDescription: z.string().describe("Short description of the project"),
  introduction: IntroductionSchema.describe(
    "Introduction section of the project"
  ),
  projectScope: ProjectScopeSchema.describe("Scope of the project"),
  design: DesignSchema.describe("Design details of the project"),
  ......
});
\end{lstlisting}

\subsection*{\texttt{/prompt}}
L’\textit{endpoint} \gls{prompt} si occupa di generare dinamicamente il \gls{prompt} che verrà utilizzato dall’\texttt{/aws-bedrock} per creare i progetti.\\
Questo \textit{endpoint} rappresenta un punto cruciale del sistema, poiché traduce i dati grezzi forniti dal \gls{frontend} in un formato strutturato e leggibile per il modello di linguaggio.\\ 

\noindent La generazione del \gls{prompt} avviene in modo statico, tramite il set di domande (\textit{preset}) inserite dall'utente. Questo approccio garantisce che i risultati del modello siano coerenti con le aspettative dell'utente, basandosi su un formato predefinito e strutturato.\\
\noindent All'interno della {\hyperref[lst:funzione-prompt]{\textit{Listing} 3.5}} è possibile osservare la funzione di generazione del \gls{prompt} implementata nel \textit{service}, a partire dai dati forniti dal \gls{frontend}.\\
Si noti la differenza tra \texttt{optionalInfo} e \texttt{additionalPrompt}, il primo è un campo opzionale che può essere fornito dall'utente la prima volta che va a generare un progetto, mentre il secondo è un \gls{prompt} aggiuntivo fornito dall'utente durante la rigenerazione del progetto.

\begin{lstlisting}[caption={Funzione di costruzione del \gls{prompt}}, label={lst:funzione-prompt}]
async constructPrompt(prompt: Prompt, additionalPrompt?: string): Promise<string> {
const result = [
    [
    "system",
    "You are a IT project manager that creates detailed project plans.",
    ],
    [
    "human",
    "Based on the following project details, generate a detailed project plan. Make sure to call the ProjectSchema function and return a JSON object containing all the fields of the Project Schema.",
    ],
    ["human", `The project is called "${prompt.projectName}".`],
    [
    "human",
    "Here are the key details for the project in a Question/Answer format:",
    ],
    ...prompt.answers.map((answer, i) => ({
    role: "human",
    content: `${i + 1}. Question: "${answer.question}\n", Answer: "${answer.answer}"`,
    })),
    ...(prompt.optionalInfo
    ? [
        {
            role: "human",
            content: `And this is some additional information for the project: ${prompt.optionalInfo}.`,
        },
        ]
    : []),
    {
    role: "human",
    content:
    "Please generate a comprehensive project plan based on the details provided above. 
    Ensure that every field in the JSON structure is thoroughly described with precise and detailed information. 
    Include specific insights, objectives, and methodologies to create a robust and actionable plan.",
    },
    ...(additionalPrompt
    ? [
        {
            role: "human",
            content: `Include also this information during the generation of the project: ${additionalPrompt}.`,
        },
        ]
    : []),
];
return JSON.stringify(result);
      }
\end{lstlisting}
\subsection*{\texttt{/pdf}}
L’\textit{endpoint} \texttt{/pdf} è responsabile della generazione dei documenti PDF a partire dai progetti creati.\\
Una volta ricevuto un progetto generato, l’\textit{endpoint} utilizza \textit{Puppeteer}, una libreria per l’elaborazione di documenti, per trasformare i dati in un \textit{file} PDF ben formattato e leggibile, tramite l'utilizzo di un \textit{template} \gls{html} predefinito, che viene popolato tramite la libreria \textit{HandleBars}.\\

\noindent Questo \textit{endpoint} svolge un ruolo fondamentale nel flusso di lavoro complessivo, poiché consente agli utenti di ottenere una rappresentazione visiva e condivisibile dei progetti generati.\\
Una volta creato, il PDF viene caricato su un \textit{bucket} \textit{AWS S3}, assicurandone la memorizzazione a lungo termine e l’accessibilità tramite un \textit{URL} univoco.\\ 

\noindent All'interno della {\hyperref[lst:funzione-generazione-pdf]{\textit{Listing} 3.6}} è possibile osservare la funzione di generazione del PDF, si noti la popolazione del template \gls{html} con i dati del progetto e il salvataggio del PDF generato su \textit{AWS S3}.
\begin{lstlisting}[caption={Funzione di generazione del PDF, con salvataggio su \textit{AWS S3}}, label={lst:funzione-generazione-pdf}]
async generatePdf(user: User, project: Project): Promise<string> {
    // Populate the HTML template    
    const content = await this.populateTemplate(project);  
    // Get the browser instance
    const browser: Browser = await this.getBrowser(); 

    const page: Page = await browser.newPage();
    // Set the content of the page
    await page.setContent(content); 

    try {
      // Generate the PDF
      const pdfBuffer: Uint8Array = await page.pdf({
        format: "A4",
        printBackground: true,
      }); 
      // Save the PDF on AWS S3
      this.savePdf(user, pdfBuffer, project.projectId, project.projectName, project.version);  
      // Return the signed URL to the frontend
      return this.getSignedUrl(user, project.projectId, project.projectName, project.version);
    } catch (error) {
      throw new Error("Failed to generate PDF");
    } finally {
      await page.close();
      await this.closeBrowser();
    }
  }
\end{lstlisting}